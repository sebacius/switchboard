// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v6.33.2
// source: api/proto/rtpmanager/v1/rtpmanager.proto

package rtpmanagerv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type SessionState int32

const (
	SessionState_SESSION_STATE_UNSPECIFIED SessionState = 0
	SessionState_SESSION_STATE_CREATED     SessionState = 1
	SessionState_SESSION_STATE_ACTIVE      SessionState = 2
	SessionState_SESSION_STATE_TERMINATED  SessionState = 3
	SessionState_SESSION_STATE_ERROR       SessionState = 4
	// Bridge-specific states
	SessionState_SESSION_STATE_PENDING_REMOTE SessionState = 5 // Waiting for remote endpoint info
	SessionState_SESSION_STATE_BRIDGED        SessionState = 6 // Part of an active bridge
)

// Enum value maps for SessionState.
var (
	SessionState_name = map[int32]string{
		0: "SESSION_STATE_UNSPECIFIED",
		1: "SESSION_STATE_CREATED",
		2: "SESSION_STATE_ACTIVE",
		3: "SESSION_STATE_TERMINATED",
		4: "SESSION_STATE_ERROR",
		5: "SESSION_STATE_PENDING_REMOTE",
		6: "SESSION_STATE_BRIDGED",
	}
	SessionState_value = map[string]int32{
		"SESSION_STATE_UNSPECIFIED":    0,
		"SESSION_STATE_CREATED":        1,
		"SESSION_STATE_ACTIVE":         2,
		"SESSION_STATE_TERMINATED":     3,
		"SESSION_STATE_ERROR":          4,
		"SESSION_STATE_PENDING_REMOTE": 5,
		"SESSION_STATE_BRIDGED":        6,
	}
)

func (x SessionState) Enum() *SessionState {
	p := new(SessionState)
	*p = x
	return p
}

func (x SessionState) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SessionState) Descriptor() protoreflect.EnumDescriptor {
	return file_api_proto_rtpmanager_v1_rtpmanager_proto_enumTypes[0].Descriptor()
}

func (SessionState) Type() protoreflect.EnumType {
	return &file_api_proto_rtpmanager_v1_rtpmanager_proto_enumTypes[0]
}

func (x SessionState) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SessionState.Descriptor instead.
func (SessionState) EnumDescriptor() ([]byte, []int) {
	return file_api_proto_rtpmanager_v1_rtpmanager_proto_rawDescGZIP(), []int{0}
}

type TerminateReason int32

const (
	TerminateReason_TERMINATE_REASON_UNSPECIFIED TerminateReason = 0
	TerminateReason_TERMINATE_REASON_NORMAL      TerminateReason = 1
	TerminateReason_TERMINATE_REASON_BYE         TerminateReason = 2
	TerminateReason_TERMINATE_REASON_CANCEL      TerminateReason = 3
	TerminateReason_TERMINATE_REASON_ERROR       TerminateReason = 4
	TerminateReason_TERMINATE_REASON_TIMEOUT     TerminateReason = 5
)

// Enum value maps for TerminateReason.
var (
	TerminateReason_name = map[int32]string{
		0: "TERMINATE_REASON_UNSPECIFIED",
		1: "TERMINATE_REASON_NORMAL",
		2: "TERMINATE_REASON_BYE",
		3: "TERMINATE_REASON_CANCEL",
		4: "TERMINATE_REASON_ERROR",
		5: "TERMINATE_REASON_TIMEOUT",
	}
	TerminateReason_value = map[string]int32{
		"TERMINATE_REASON_UNSPECIFIED": 0,
		"TERMINATE_REASON_NORMAL":      1,
		"TERMINATE_REASON_BYE":         2,
		"TERMINATE_REASON_CANCEL":      3,
		"TERMINATE_REASON_ERROR":       4,
		"TERMINATE_REASON_TIMEOUT":     5,
	}
)

func (x TerminateReason) Enum() *TerminateReason {
	p := new(TerminateReason)
	*p = x
	return p
}

func (x TerminateReason) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TerminateReason) Descriptor() protoreflect.EnumDescriptor {
	return file_api_proto_rtpmanager_v1_rtpmanager_proto_enumTypes[1].Descriptor()
}

func (TerminateReason) Type() protoreflect.EnumType {
	return &file_api_proto_rtpmanager_v1_rtpmanager_proto_enumTypes[1]
}

func (x TerminateReason) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TerminateReason.Descriptor instead.
func (TerminateReason) EnumDescriptor() ([]byte, []int) {
	return file_api_proto_rtpmanager_v1_rtpmanager_proto_rawDescGZIP(), []int{1}
}

type CreateSessionRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Call-ID from SIP for correlation
	CallId string `protobuf:"bytes,1,opt,name=call_id,json=callId,proto3" json:"call_id,omitempty"`
	// Remote endpoint from client SDP
	RemoteAddr string `protobuf:"bytes,2,opt,name=remote_addr,json=remoteAddr,proto3" json:"remote_addr,omitempty"`
	RemotePort int32  `protobuf:"varint,3,opt,name=remote_port,json=remotePort,proto3" json:"remote_port,omitempty"`
	// Codecs offered by remote party (payload type strings: "0", "8", etc.)
	OfferedCodecs []string `protobuf:"bytes,4,rep,name=offered_codecs,json=offeredCodecs,proto3" json:"offered_codecs,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateSessionRequest) Reset() {
	*x = CreateSessionRequest{}
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateSessionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateSessionRequest) ProtoMessage() {}

func (x *CreateSessionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateSessionRequest.ProtoReflect.Descriptor instead.
func (*CreateSessionRequest) Descriptor() ([]byte, []int) {
	return file_api_proto_rtpmanager_v1_rtpmanager_proto_rawDescGZIP(), []int{0}
}

func (x *CreateSessionRequest) GetCallId() string {
	if x != nil {
		return x.CallId
	}
	return ""
}

func (x *CreateSessionRequest) GetRemoteAddr() string {
	if x != nil {
		return x.RemoteAddr
	}
	return ""
}

func (x *CreateSessionRequest) GetRemotePort() int32 {
	if x != nil {
		return x.RemotePort
	}
	return 0
}

func (x *CreateSessionRequest) GetOfferedCodecs() []string {
	if x != nil {
		return x.OfferedCodecs
	}
	return nil
}

type CreateSessionResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique session ID for subsequent calls
	SessionId string `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	// Allocated local endpoint for SDP answer
	LocalAddr string `protobuf:"bytes,2,opt,name=local_addr,json=localAddr,proto3" json:"local_addr,omitempty"`
	LocalPort int32  `protobuf:"varint,3,opt,name=local_port,json=localPort,proto3" json:"local_port,omitempty"`
	// Selected codec after negotiation
	SelectedCodec string `protobuf:"bytes,4,opt,name=selected_codec,json=selectedCodec,proto3" json:"selected_codec,omitempty"`
	// Complete SDP body for SIP response
	SdpBody []byte `protobuf:"bytes,5,opt,name=sdp_body,json=sdpBody,proto3" json:"sdp_body,omitempty"`
	// Status
	Status        *SessionStatus `protobuf:"bytes,6,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateSessionResponse) Reset() {
	*x = CreateSessionResponse{}
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateSessionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateSessionResponse) ProtoMessage() {}

func (x *CreateSessionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateSessionResponse.ProtoReflect.Descriptor instead.
func (*CreateSessionResponse) Descriptor() ([]byte, []int) {
	return file_api_proto_rtpmanager_v1_rtpmanager_proto_rawDescGZIP(), []int{1}
}

func (x *CreateSessionResponse) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *CreateSessionResponse) GetLocalAddr() string {
	if x != nil {
		return x.LocalAddr
	}
	return ""
}

func (x *CreateSessionResponse) GetLocalPort() int32 {
	if x != nil {
		return x.LocalPort
	}
	return 0
}

func (x *CreateSessionResponse) GetSelectedCodec() string {
	if x != nil {
		return x.SelectedCodec
	}
	return ""
}

func (x *CreateSessionResponse) GetSdpBody() []byte {
	if x != nil {
		return x.SdpBody
	}
	return nil
}

func (x *CreateSessionResponse) GetStatus() *SessionStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

type DestroySessionRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SessionId     string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	Reason        TerminateReason        `protobuf:"varint,2,opt,name=reason,proto3,enum=rtpmanager.v1.TerminateReason" json:"reason,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DestroySessionRequest) Reset() {
	*x = DestroySessionRequest{}
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DestroySessionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DestroySessionRequest) ProtoMessage() {}

func (x *DestroySessionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DestroySessionRequest.ProtoReflect.Descriptor instead.
func (*DestroySessionRequest) Descriptor() ([]byte, []int) {
	return file_api_proto_rtpmanager_v1_rtpmanager_proto_rawDescGZIP(), []int{2}
}

func (x *DestroySessionRequest) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *DestroySessionRequest) GetReason() TerminateReason {
	if x != nil {
		return x.Reason
	}
	return TerminateReason_TERMINATE_REASON_UNSPECIFIED
}

type DestroySessionResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SessionId     string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	Status        *SessionStatus         `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DestroySessionResponse) Reset() {
	*x = DestroySessionResponse{}
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DestroySessionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DestroySessionResponse) ProtoMessage() {}

func (x *DestroySessionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DestroySessionResponse.ProtoReflect.Descriptor instead.
func (*DestroySessionResponse) Descriptor() ([]byte, []int) {
	return file_api_proto_rtpmanager_v1_rtpmanager_proto_rawDescGZIP(), []int{3}
}

func (x *DestroySessionResponse) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *DestroySessionResponse) GetStatus() *SessionStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

type PlayAudioRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SessionId     string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	FilePath      string                 `protobuf:"bytes,2,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`
	Loop          bool                   `protobuf:"varint,3,opt,name=loop,proto3" json:"loop,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PlayAudioRequest) Reset() {
	*x = PlayAudioRequest{}
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PlayAudioRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PlayAudioRequest) ProtoMessage() {}

func (x *PlayAudioRequest) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PlayAudioRequest.ProtoReflect.Descriptor instead.
func (*PlayAudioRequest) Descriptor() ([]byte, []int) {
	return file_api_proto_rtpmanager_v1_rtpmanager_proto_rawDescGZIP(), []int{4}
}

func (x *PlayAudioRequest) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *PlayAudioRequest) GetFilePath() string {
	if x != nil {
		return x.FilePath
	}
	return ""
}

func (x *PlayAudioRequest) GetLoop() bool {
	if x != nil {
		return x.Loop
	}
	return false
}

type PlaybackEvent struct {
	state     protoimpl.MessageState `protogen:"open.v1"`
	SessionId string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	// Types that are valid to be assigned to Event:
	//
	//	*PlaybackEvent_Started
	//	*PlaybackEvent_Progress
	//	*PlaybackEvent_Completed
	//	*PlaybackEvent_Error
	//	*PlaybackEvent_Stopped
	Event         isPlaybackEvent_Event `protobuf_oneof:"event"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PlaybackEvent) Reset() {
	*x = PlaybackEvent{}
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PlaybackEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PlaybackEvent) ProtoMessage() {}

func (x *PlaybackEvent) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PlaybackEvent.ProtoReflect.Descriptor instead.
func (*PlaybackEvent) Descriptor() ([]byte, []int) {
	return file_api_proto_rtpmanager_v1_rtpmanager_proto_rawDescGZIP(), []int{5}
}

func (x *PlaybackEvent) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *PlaybackEvent) GetEvent() isPlaybackEvent_Event {
	if x != nil {
		return x.Event
	}
	return nil
}

func (x *PlaybackEvent) GetStarted() *PlaybackStarted {
	if x != nil {
		if x, ok := x.Event.(*PlaybackEvent_Started); ok {
			return x.Started
		}
	}
	return nil
}

func (x *PlaybackEvent) GetProgress() *PlaybackProgress {
	if x != nil {
		if x, ok := x.Event.(*PlaybackEvent_Progress); ok {
			return x.Progress
		}
	}
	return nil
}

func (x *PlaybackEvent) GetCompleted() *PlaybackCompleted {
	if x != nil {
		if x, ok := x.Event.(*PlaybackEvent_Completed); ok {
			return x.Completed
		}
	}
	return nil
}

func (x *PlaybackEvent) GetError() *PlaybackError {
	if x != nil {
		if x, ok := x.Event.(*PlaybackEvent_Error); ok {
			return x.Error
		}
	}
	return nil
}

func (x *PlaybackEvent) GetStopped() *PlaybackStopped {
	if x != nil {
		if x, ok := x.Event.(*PlaybackEvent_Stopped); ok {
			return x.Stopped
		}
	}
	return nil
}

type isPlaybackEvent_Event interface {
	isPlaybackEvent_Event()
}

type PlaybackEvent_Started struct {
	Started *PlaybackStarted `protobuf:"bytes,2,opt,name=started,proto3,oneof"`
}

type PlaybackEvent_Progress struct {
	Progress *PlaybackProgress `protobuf:"bytes,3,opt,name=progress,proto3,oneof"`
}

type PlaybackEvent_Completed struct {
	Completed *PlaybackCompleted `protobuf:"bytes,4,opt,name=completed,proto3,oneof"`
}

type PlaybackEvent_Error struct {
	Error *PlaybackError `protobuf:"bytes,5,opt,name=error,proto3,oneof"`
}

type PlaybackEvent_Stopped struct {
	Stopped *PlaybackStopped `protobuf:"bytes,6,opt,name=stopped,proto3,oneof"`
}

func (*PlaybackEvent_Started) isPlaybackEvent_Event() {}

func (*PlaybackEvent_Progress) isPlaybackEvent_Event() {}

func (*PlaybackEvent_Completed) isPlaybackEvent_Event() {}

func (*PlaybackEvent_Error) isPlaybackEvent_Event() {}

func (*PlaybackEvent_Stopped) isPlaybackEvent_Event() {}

type PlaybackStarted struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TotalFrames   int32                  `protobuf:"varint,1,opt,name=total_frames,json=totalFrames,proto3" json:"total_frames,omitempty"`
	DurationMs    int32                  `protobuf:"varint,2,opt,name=duration_ms,json=durationMs,proto3" json:"duration_ms,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PlaybackStarted) Reset() {
	*x = PlaybackStarted{}
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PlaybackStarted) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PlaybackStarted) ProtoMessage() {}

func (x *PlaybackStarted) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PlaybackStarted.ProtoReflect.Descriptor instead.
func (*PlaybackStarted) Descriptor() ([]byte, []int) {
	return file_api_proto_rtpmanager_v1_rtpmanager_proto_rawDescGZIP(), []int{6}
}

func (x *PlaybackStarted) GetTotalFrames() int32 {
	if x != nil {
		return x.TotalFrames
	}
	return 0
}

func (x *PlaybackStarted) GetDurationMs() int32 {
	if x != nil {
		return x.DurationMs
	}
	return 0
}

type PlaybackProgress struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	FramesSent      int32                  `protobuf:"varint,1,opt,name=frames_sent,json=framesSent,proto3" json:"frames_sent,omitempty"`
	PercentComplete float32                `protobuf:"fixed32,2,opt,name=percent_complete,json=percentComplete,proto3" json:"percent_complete,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *PlaybackProgress) Reset() {
	*x = PlaybackProgress{}
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PlaybackProgress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PlaybackProgress) ProtoMessage() {}

func (x *PlaybackProgress) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PlaybackProgress.ProtoReflect.Descriptor instead.
func (*PlaybackProgress) Descriptor() ([]byte, []int) {
	return file_api_proto_rtpmanager_v1_rtpmanager_proto_rawDescGZIP(), []int{7}
}

func (x *PlaybackProgress) GetFramesSent() int32 {
	if x != nil {
		return x.FramesSent
	}
	return 0
}

func (x *PlaybackProgress) GetPercentComplete() float32 {
	if x != nil {
		return x.PercentComplete
	}
	return 0
}

type PlaybackCompleted struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	TotalFramesSent int32                  `protobuf:"varint,1,opt,name=total_frames_sent,json=totalFramesSent,proto3" json:"total_frames_sent,omitempty"`
	DurationMs      int32                  `protobuf:"varint,2,opt,name=duration_ms,json=durationMs,proto3" json:"duration_ms,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *PlaybackCompleted) Reset() {
	*x = PlaybackCompleted{}
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PlaybackCompleted) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PlaybackCompleted) ProtoMessage() {}

func (x *PlaybackCompleted) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PlaybackCompleted.ProtoReflect.Descriptor instead.
func (*PlaybackCompleted) Descriptor() ([]byte, []int) {
	return file_api_proto_rtpmanager_v1_rtpmanager_proto_rawDescGZIP(), []int{8}
}

func (x *PlaybackCompleted) GetTotalFramesSent() int32 {
	if x != nil {
		return x.TotalFramesSent
	}
	return 0
}

func (x *PlaybackCompleted) GetDurationMs() int32 {
	if x != nil {
		return x.DurationMs
	}
	return 0
}

type PlaybackError struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Code          string                 `protobuf:"bytes,1,opt,name=code,proto3" json:"code,omitempty"`
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PlaybackError) Reset() {
	*x = PlaybackError{}
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PlaybackError) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PlaybackError) ProtoMessage() {}

func (x *PlaybackError) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PlaybackError.ProtoReflect.Descriptor instead.
func (*PlaybackError) Descriptor() ([]byte, []int) {
	return file_api_proto_rtpmanager_v1_rtpmanager_proto_rawDescGZIP(), []int{9}
}

func (x *PlaybackError) GetCode() string {
	if x != nil {
		return x.Code
	}
	return ""
}

func (x *PlaybackError) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

type PlaybackStopped struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Reason        string                 `protobuf:"bytes,1,opt,name=reason,proto3" json:"reason,omitempty"`
	FramesSent    int32                  `protobuf:"varint,2,opt,name=frames_sent,json=framesSent,proto3" json:"frames_sent,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PlaybackStopped) Reset() {
	*x = PlaybackStopped{}
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PlaybackStopped) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PlaybackStopped) ProtoMessage() {}

func (x *PlaybackStopped) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PlaybackStopped.ProtoReflect.Descriptor instead.
func (*PlaybackStopped) Descriptor() ([]byte, []int) {
	return file_api_proto_rtpmanager_v1_rtpmanager_proto_rawDescGZIP(), []int{10}
}

func (x *PlaybackStopped) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

func (x *PlaybackStopped) GetFramesSent() int32 {
	if x != nil {
		return x.FramesSent
	}
	return 0
}

type StopAudioRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SessionId     string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StopAudioRequest) Reset() {
	*x = StopAudioRequest{}
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StopAudioRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StopAudioRequest) ProtoMessage() {}

func (x *StopAudioRequest) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StopAudioRequest.ProtoReflect.Descriptor instead.
func (*StopAudioRequest) Descriptor() ([]byte, []int) {
	return file_api_proto_rtpmanager_v1_rtpmanager_proto_rawDescGZIP(), []int{11}
}

func (x *StopAudioRequest) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

type StopAudioResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SessionId     string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	WasPlaying    bool                   `protobuf:"varint,2,opt,name=was_playing,json=wasPlaying,proto3" json:"was_playing,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StopAudioResponse) Reset() {
	*x = StopAudioResponse{}
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StopAudioResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StopAudioResponse) ProtoMessage() {}

func (x *StopAudioResponse) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StopAudioResponse.ProtoReflect.Descriptor instead.
func (*StopAudioResponse) Descriptor() ([]byte, []int) {
	return file_api_proto_rtpmanager_v1_rtpmanager_proto_rawDescGZIP(), []int{12}
}

func (x *StopAudioResponse) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *StopAudioResponse) GetWasPlaying() bool {
	if x != nil {
		return x.WasPlaying
	}
	return false
}

type HealthRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HealthRequest) Reset() {
	*x = HealthRequest{}
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HealthRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HealthRequest) ProtoMessage() {}

func (x *HealthRequest) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HealthRequest.ProtoReflect.Descriptor instead.
func (*HealthRequest) Descriptor() ([]byte, []int) {
	return file_api_proto_rtpmanager_v1_rtpmanager_proto_rawDescGZIP(), []int{13}
}

type HealthResponse struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	Healthy        bool                   `protobuf:"varint,1,opt,name=healthy,proto3" json:"healthy,omitempty"`
	ActiveSessions int32                  `protobuf:"varint,2,opt,name=active_sessions,json=activeSessions,proto3" json:"active_sessions,omitempty"`
	AvailablePorts int32                  `protobuf:"varint,3,opt,name=available_ports,json=availablePorts,proto3" json:"available_ports,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *HealthResponse) Reset() {
	*x = HealthResponse{}
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HealthResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HealthResponse) ProtoMessage() {}

func (x *HealthResponse) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HealthResponse.ProtoReflect.Descriptor instead.
func (*HealthResponse) Descriptor() ([]byte, []int) {
	return file_api_proto_rtpmanager_v1_rtpmanager_proto_rawDescGZIP(), []int{14}
}

func (x *HealthResponse) GetHealthy() bool {
	if x != nil {
		return x.Healthy
	}
	return false
}

func (x *HealthResponse) GetActiveSessions() int32 {
	if x != nil {
		return x.ActiveSessions
	}
	return 0
}

func (x *HealthResponse) GetAvailablePorts() int32 {
	if x != nil {
		return x.AvailablePorts
	}
	return 0
}

type SessionStatus struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	State         SessionState           `protobuf:"varint,1,opt,name=state,proto3,enum=rtpmanager.v1.SessionState" json:"state,omitempty"`
	ErrorMessage  string                 `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SessionStatus) Reset() {
	*x = SessionStatus{}
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SessionStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SessionStatus) ProtoMessage() {}

func (x *SessionStatus) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SessionStatus.ProtoReflect.Descriptor instead.
func (*SessionStatus) Descriptor() ([]byte, []int) {
	return file_api_proto_rtpmanager_v1_rtpmanager_proto_rawDescGZIP(), []int{15}
}

func (x *SessionStatus) GetState() SessionState {
	if x != nil {
		return x.State
	}
	return SessionState_SESSION_STATE_UNSPECIFIED
}

func (x *SessionStatus) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

type UpdateSessionRemoteRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SessionId     string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	RemoteAddr    string                 `protobuf:"bytes,2,opt,name=remote_addr,json=remoteAddr,proto3" json:"remote_addr,omitempty"`
	RemotePort    int32                  `protobuf:"varint,3,opt,name=remote_port,json=remotePort,proto3" json:"remote_port,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateSessionRemoteRequest) Reset() {
	*x = UpdateSessionRemoteRequest{}
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateSessionRemoteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateSessionRemoteRequest) ProtoMessage() {}

func (x *UpdateSessionRemoteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateSessionRemoteRequest.ProtoReflect.Descriptor instead.
func (*UpdateSessionRemoteRequest) Descriptor() ([]byte, []int) {
	return file_api_proto_rtpmanager_v1_rtpmanager_proto_rawDescGZIP(), []int{16}
}

func (x *UpdateSessionRemoteRequest) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *UpdateSessionRemoteRequest) GetRemoteAddr() string {
	if x != nil {
		return x.RemoteAddr
	}
	return ""
}

func (x *UpdateSessionRemoteRequest) GetRemotePort() int32 {
	if x != nil {
		return x.RemotePort
	}
	return 0
}

type UpdateSessionRemoteResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SessionId     string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	Status        *SessionStatus         `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateSessionRemoteResponse) Reset() {
	*x = UpdateSessionRemoteResponse{}
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateSessionRemoteResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateSessionRemoteResponse) ProtoMessage() {}

func (x *UpdateSessionRemoteResponse) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateSessionRemoteResponse.ProtoReflect.Descriptor instead.
func (*UpdateSessionRemoteResponse) Descriptor() ([]byte, []int) {
	return file_api_proto_rtpmanager_v1_rtpmanager_proto_rawDescGZIP(), []int{17}
}

func (x *UpdateSessionRemoteResponse) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *UpdateSessionRemoteResponse) GetStatus() *SessionStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

type BridgeMediaRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Session ID for leg A (typically caller side)
	SessionAId string `protobuf:"bytes,1,opt,name=session_a_id,json=sessionAId,proto3" json:"session_a_id,omitempty"`
	// Session ID for leg B (typically callee side)
	SessionBId    string `protobuf:"bytes,2,opt,name=session_b_id,json=sessionBId,proto3" json:"session_b_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BridgeMediaRequest) Reset() {
	*x = BridgeMediaRequest{}
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BridgeMediaRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BridgeMediaRequest) ProtoMessage() {}

func (x *BridgeMediaRequest) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BridgeMediaRequest.ProtoReflect.Descriptor instead.
func (*BridgeMediaRequest) Descriptor() ([]byte, []int) {
	return file_api_proto_rtpmanager_v1_rtpmanager_proto_rawDescGZIP(), []int{18}
}

func (x *BridgeMediaRequest) GetSessionAId() string {
	if x != nil {
		return x.SessionAId
	}
	return ""
}

func (x *BridgeMediaRequest) GetSessionBId() string {
	if x != nil {
		return x.SessionBId
	}
	return ""
}

type BridgeMediaResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique bridge ID for managing the bridge
	BridgeId      string         `protobuf:"bytes,1,opt,name=bridge_id,json=bridgeId,proto3" json:"bridge_id,omitempty"`
	Status        *SessionStatus `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BridgeMediaResponse) Reset() {
	*x = BridgeMediaResponse{}
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BridgeMediaResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BridgeMediaResponse) ProtoMessage() {}

func (x *BridgeMediaResponse) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BridgeMediaResponse.ProtoReflect.Descriptor instead.
func (*BridgeMediaResponse) Descriptor() ([]byte, []int) {
	return file_api_proto_rtpmanager_v1_rtpmanager_proto_rawDescGZIP(), []int{19}
}

func (x *BridgeMediaResponse) GetBridgeId() string {
	if x != nil {
		return x.BridgeId
	}
	return ""
}

func (x *BridgeMediaResponse) GetStatus() *SessionStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

type UnbridgeMediaRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Can specify by bridge_id OR by session_id
	BridgeId      string `protobuf:"bytes,1,opt,name=bridge_id,json=bridgeId,proto3" json:"bridge_id,omitempty"`
	SessionId     string `protobuf:"bytes,2,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UnbridgeMediaRequest) Reset() {
	*x = UnbridgeMediaRequest{}
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UnbridgeMediaRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnbridgeMediaRequest) ProtoMessage() {}

func (x *UnbridgeMediaRequest) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnbridgeMediaRequest.ProtoReflect.Descriptor instead.
func (*UnbridgeMediaRequest) Descriptor() ([]byte, []int) {
	return file_api_proto_rtpmanager_v1_rtpmanager_proto_rawDescGZIP(), []int{20}
}

func (x *UnbridgeMediaRequest) GetBridgeId() string {
	if x != nil {
		return x.BridgeId
	}
	return ""
}

func (x *UnbridgeMediaRequest) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

type UnbridgeMediaResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	BridgeId      string                 `protobuf:"bytes,1,opt,name=bridge_id,json=bridgeId,proto3" json:"bridge_id,omitempty"`
	Status        *SessionStatus         `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UnbridgeMediaResponse) Reset() {
	*x = UnbridgeMediaResponse{}
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UnbridgeMediaResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnbridgeMediaResponse) ProtoMessage() {}

func (x *UnbridgeMediaResponse) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnbridgeMediaResponse.ProtoReflect.Descriptor instead.
func (*UnbridgeMediaResponse) Descriptor() ([]byte, []int) {
	return file_api_proto_rtpmanager_v1_rtpmanager_proto_rawDescGZIP(), []int{21}
}

func (x *UnbridgeMediaResponse) GetBridgeId() string {
	if x != nil {
		return x.BridgeId
	}
	return ""
}

func (x *UnbridgeMediaResponse) GetStatus() *SessionStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

var File_api_proto_rtpmanager_v1_rtpmanager_proto protoreflect.FileDescriptor

const file_api_proto_rtpmanager_v1_rtpmanager_proto_rawDesc = "" +
	"\n" +
	"(api/proto/rtpmanager/v1/rtpmanager.proto\x12\rrtpmanager.v1\"\x98\x01\n" +
	"\x14CreateSessionRequest\x12\x17\n" +
	"\acall_id\x18\x01 \x01(\tR\x06callId\x12\x1f\n" +
	"\vremote_addr\x18\x02 \x01(\tR\n" +
	"remoteAddr\x12\x1f\n" +
	"\vremote_port\x18\x03 \x01(\x05R\n" +
	"remotePort\x12%\n" +
	"\x0eoffered_codecs\x18\x04 \x03(\tR\rofferedCodecs\"\xec\x01\n" +
	"\x15CreateSessionResponse\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\x12\x1d\n" +
	"\n" +
	"local_addr\x18\x02 \x01(\tR\tlocalAddr\x12\x1d\n" +
	"\n" +
	"local_port\x18\x03 \x01(\x05R\tlocalPort\x12%\n" +
	"\x0eselected_codec\x18\x04 \x01(\tR\rselectedCodec\x12\x19\n" +
	"\bsdp_body\x18\x05 \x01(\fR\asdpBody\x124\n" +
	"\x06status\x18\x06 \x01(\v2\x1c.rtpmanager.v1.SessionStatusR\x06status\"n\n" +
	"\x15DestroySessionRequest\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\x126\n" +
	"\x06reason\x18\x02 \x01(\x0e2\x1e.rtpmanager.v1.TerminateReasonR\x06reason\"m\n" +
	"\x16DestroySessionResponse\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\x124\n" +
	"\x06status\x18\x02 \x01(\v2\x1c.rtpmanager.v1.SessionStatusR\x06status\"b\n" +
	"\x10PlayAudioRequest\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\x12\x1b\n" +
	"\tfile_path\x18\x02 \x01(\tR\bfilePath\x12\x12\n" +
	"\x04loop\x18\x03 \x01(\bR\x04loop\"\xe6\x02\n" +
	"\rPlaybackEvent\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\x12:\n" +
	"\astarted\x18\x02 \x01(\v2\x1e.rtpmanager.v1.PlaybackStartedH\x00R\astarted\x12=\n" +
	"\bprogress\x18\x03 \x01(\v2\x1f.rtpmanager.v1.PlaybackProgressH\x00R\bprogress\x12@\n" +
	"\tcompleted\x18\x04 \x01(\v2 .rtpmanager.v1.PlaybackCompletedH\x00R\tcompleted\x124\n" +
	"\x05error\x18\x05 \x01(\v2\x1c.rtpmanager.v1.PlaybackErrorH\x00R\x05error\x12:\n" +
	"\astopped\x18\x06 \x01(\v2\x1e.rtpmanager.v1.PlaybackStoppedH\x00R\astoppedB\a\n" +
	"\x05event\"U\n" +
	"\x0fPlaybackStarted\x12!\n" +
	"\ftotal_frames\x18\x01 \x01(\x05R\vtotalFrames\x12\x1f\n" +
	"\vduration_ms\x18\x02 \x01(\x05R\n" +
	"durationMs\"^\n" +
	"\x10PlaybackProgress\x12\x1f\n" +
	"\vframes_sent\x18\x01 \x01(\x05R\n" +
	"framesSent\x12)\n" +
	"\x10percent_complete\x18\x02 \x01(\x02R\x0fpercentComplete\"`\n" +
	"\x11PlaybackCompleted\x12*\n" +
	"\x11total_frames_sent\x18\x01 \x01(\x05R\x0ftotalFramesSent\x12\x1f\n" +
	"\vduration_ms\x18\x02 \x01(\x05R\n" +
	"durationMs\"=\n" +
	"\rPlaybackError\x12\x12\n" +
	"\x04code\x18\x01 \x01(\tR\x04code\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\"J\n" +
	"\x0fPlaybackStopped\x12\x16\n" +
	"\x06reason\x18\x01 \x01(\tR\x06reason\x12\x1f\n" +
	"\vframes_sent\x18\x02 \x01(\x05R\n" +
	"framesSent\"1\n" +
	"\x10StopAudioRequest\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\"S\n" +
	"\x11StopAudioResponse\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\x12\x1f\n" +
	"\vwas_playing\x18\x02 \x01(\bR\n" +
	"wasPlaying\"\x0f\n" +
	"\rHealthRequest\"|\n" +
	"\x0eHealthResponse\x12\x18\n" +
	"\ahealthy\x18\x01 \x01(\bR\ahealthy\x12'\n" +
	"\x0factive_sessions\x18\x02 \x01(\x05R\x0eactiveSessions\x12'\n" +
	"\x0favailable_ports\x18\x03 \x01(\x05R\x0eavailablePorts\"g\n" +
	"\rSessionStatus\x121\n" +
	"\x05state\x18\x01 \x01(\x0e2\x1b.rtpmanager.v1.SessionStateR\x05state\x12#\n" +
	"\rerror_message\x18\x02 \x01(\tR\ferrorMessage\"}\n" +
	"\x1aUpdateSessionRemoteRequest\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\x12\x1f\n" +
	"\vremote_addr\x18\x02 \x01(\tR\n" +
	"remoteAddr\x12\x1f\n" +
	"\vremote_port\x18\x03 \x01(\x05R\n" +
	"remotePort\"r\n" +
	"\x1bUpdateSessionRemoteResponse\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\x124\n" +
	"\x06status\x18\x02 \x01(\v2\x1c.rtpmanager.v1.SessionStatusR\x06status\"X\n" +
	"\x12BridgeMediaRequest\x12 \n" +
	"\fsession_a_id\x18\x01 \x01(\tR\n" +
	"sessionAId\x12 \n" +
	"\fsession_b_id\x18\x02 \x01(\tR\n" +
	"sessionBId\"h\n" +
	"\x13BridgeMediaResponse\x12\x1b\n" +
	"\tbridge_id\x18\x01 \x01(\tR\bbridgeId\x124\n" +
	"\x06status\x18\x02 \x01(\v2\x1c.rtpmanager.v1.SessionStatusR\x06status\"R\n" +
	"\x14UnbridgeMediaRequest\x12\x1b\n" +
	"\tbridge_id\x18\x01 \x01(\tR\bbridgeId\x12\x1d\n" +
	"\n" +
	"session_id\x18\x02 \x01(\tR\tsessionId\"j\n" +
	"\x15UnbridgeMediaResponse\x12\x1b\n" +
	"\tbridge_id\x18\x01 \x01(\tR\bbridgeId\x124\n" +
	"\x06status\x18\x02 \x01(\v2\x1c.rtpmanager.v1.SessionStatusR\x06status*\xd6\x01\n" +
	"\fSessionState\x12\x1d\n" +
	"\x19SESSION_STATE_UNSPECIFIED\x10\x00\x12\x19\n" +
	"\x15SESSION_STATE_CREATED\x10\x01\x12\x18\n" +
	"\x14SESSION_STATE_ACTIVE\x10\x02\x12\x1c\n" +
	"\x18SESSION_STATE_TERMINATED\x10\x03\x12\x17\n" +
	"\x13SESSION_STATE_ERROR\x10\x04\x12 \n" +
	"\x1cSESSION_STATE_PENDING_REMOTE\x10\x05\x12\x19\n" +
	"\x15SESSION_STATE_BRIDGED\x10\x06*\xc1\x01\n" +
	"\x0fTerminateReason\x12 \n" +
	"\x1cTERMINATE_REASON_UNSPECIFIED\x10\x00\x12\x1b\n" +
	"\x17TERMINATE_REASON_NORMAL\x10\x01\x12\x18\n" +
	"\x14TERMINATE_REASON_BYE\x10\x02\x12\x1b\n" +
	"\x17TERMINATE_REASON_CANCEL\x10\x03\x12\x1a\n" +
	"\x16TERMINATE_REASON_ERROR\x10\x04\x12\x1c\n" +
	"\x18TERMINATE_REASON_TIMEOUT\x10\x052\xd3\x05\n" +
	"\x11RTPManagerService\x12Z\n" +
	"\rCreateSession\x12#.rtpmanager.v1.CreateSessionRequest\x1a$.rtpmanager.v1.CreateSessionResponse\x12]\n" +
	"\x0eDestroySession\x12$.rtpmanager.v1.DestroySessionRequest\x1a%.rtpmanager.v1.DestroySessionResponse\x12L\n" +
	"\tPlayAudio\x12\x1f.rtpmanager.v1.PlayAudioRequest\x1a\x1c.rtpmanager.v1.PlaybackEvent0\x01\x12N\n" +
	"\tStopAudio\x12\x1f.rtpmanager.v1.StopAudioRequest\x1a .rtpmanager.v1.StopAudioResponse\x12E\n" +
	"\x06Health\x12\x1c.rtpmanager.v1.HealthRequest\x1a\x1d.rtpmanager.v1.HealthResponse\x12l\n" +
	"\x13UpdateSessionRemote\x12).rtpmanager.v1.UpdateSessionRemoteRequest\x1a*.rtpmanager.v1.UpdateSessionRemoteResponse\x12T\n" +
	"\vBridgeMedia\x12!.rtpmanager.v1.BridgeMediaRequest\x1a\".rtpmanager.v1.BridgeMediaResponse\x12Z\n" +
	"\rUnbridgeMedia\x12#.rtpmanager.v1.UnbridgeMediaRequest\x1a$.rtpmanager.v1.UnbridgeMediaResponseB=Z;github.com/sebas/switchboard/pkg/rtpmanager/v1;rtpmanagerv1b\x06proto3"

var (
	file_api_proto_rtpmanager_v1_rtpmanager_proto_rawDescOnce sync.Once
	file_api_proto_rtpmanager_v1_rtpmanager_proto_rawDescData []byte
)

func file_api_proto_rtpmanager_v1_rtpmanager_proto_rawDescGZIP() []byte {
	file_api_proto_rtpmanager_v1_rtpmanager_proto_rawDescOnce.Do(func() {
		file_api_proto_rtpmanager_v1_rtpmanager_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_api_proto_rtpmanager_v1_rtpmanager_proto_rawDesc), len(file_api_proto_rtpmanager_v1_rtpmanager_proto_rawDesc)))
	})
	return file_api_proto_rtpmanager_v1_rtpmanager_proto_rawDescData
}

var file_api_proto_rtpmanager_v1_rtpmanager_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes = make([]protoimpl.MessageInfo, 22)
var file_api_proto_rtpmanager_v1_rtpmanager_proto_goTypes = []any{
	(SessionState)(0),                   // 0: rtpmanager.v1.SessionState
	(TerminateReason)(0),                // 1: rtpmanager.v1.TerminateReason
	(*CreateSessionRequest)(nil),        // 2: rtpmanager.v1.CreateSessionRequest
	(*CreateSessionResponse)(nil),       // 3: rtpmanager.v1.CreateSessionResponse
	(*DestroySessionRequest)(nil),       // 4: rtpmanager.v1.DestroySessionRequest
	(*DestroySessionResponse)(nil),      // 5: rtpmanager.v1.DestroySessionResponse
	(*PlayAudioRequest)(nil),            // 6: rtpmanager.v1.PlayAudioRequest
	(*PlaybackEvent)(nil),               // 7: rtpmanager.v1.PlaybackEvent
	(*PlaybackStarted)(nil),             // 8: rtpmanager.v1.PlaybackStarted
	(*PlaybackProgress)(nil),            // 9: rtpmanager.v1.PlaybackProgress
	(*PlaybackCompleted)(nil),           // 10: rtpmanager.v1.PlaybackCompleted
	(*PlaybackError)(nil),               // 11: rtpmanager.v1.PlaybackError
	(*PlaybackStopped)(nil),             // 12: rtpmanager.v1.PlaybackStopped
	(*StopAudioRequest)(nil),            // 13: rtpmanager.v1.StopAudioRequest
	(*StopAudioResponse)(nil),           // 14: rtpmanager.v1.StopAudioResponse
	(*HealthRequest)(nil),               // 15: rtpmanager.v1.HealthRequest
	(*HealthResponse)(nil),              // 16: rtpmanager.v1.HealthResponse
	(*SessionStatus)(nil),               // 17: rtpmanager.v1.SessionStatus
	(*UpdateSessionRemoteRequest)(nil),  // 18: rtpmanager.v1.UpdateSessionRemoteRequest
	(*UpdateSessionRemoteResponse)(nil), // 19: rtpmanager.v1.UpdateSessionRemoteResponse
	(*BridgeMediaRequest)(nil),          // 20: rtpmanager.v1.BridgeMediaRequest
	(*BridgeMediaResponse)(nil),         // 21: rtpmanager.v1.BridgeMediaResponse
	(*UnbridgeMediaRequest)(nil),        // 22: rtpmanager.v1.UnbridgeMediaRequest
	(*UnbridgeMediaResponse)(nil),       // 23: rtpmanager.v1.UnbridgeMediaResponse
}
var file_api_proto_rtpmanager_v1_rtpmanager_proto_depIdxs = []int32{
	17, // 0: rtpmanager.v1.CreateSessionResponse.status:type_name -> rtpmanager.v1.SessionStatus
	1,  // 1: rtpmanager.v1.DestroySessionRequest.reason:type_name -> rtpmanager.v1.TerminateReason
	17, // 2: rtpmanager.v1.DestroySessionResponse.status:type_name -> rtpmanager.v1.SessionStatus
	8,  // 3: rtpmanager.v1.PlaybackEvent.started:type_name -> rtpmanager.v1.PlaybackStarted
	9,  // 4: rtpmanager.v1.PlaybackEvent.progress:type_name -> rtpmanager.v1.PlaybackProgress
	10, // 5: rtpmanager.v1.PlaybackEvent.completed:type_name -> rtpmanager.v1.PlaybackCompleted
	11, // 6: rtpmanager.v1.PlaybackEvent.error:type_name -> rtpmanager.v1.PlaybackError
	12, // 7: rtpmanager.v1.PlaybackEvent.stopped:type_name -> rtpmanager.v1.PlaybackStopped
	0,  // 8: rtpmanager.v1.SessionStatus.state:type_name -> rtpmanager.v1.SessionState
	17, // 9: rtpmanager.v1.UpdateSessionRemoteResponse.status:type_name -> rtpmanager.v1.SessionStatus
	17, // 10: rtpmanager.v1.BridgeMediaResponse.status:type_name -> rtpmanager.v1.SessionStatus
	17, // 11: rtpmanager.v1.UnbridgeMediaResponse.status:type_name -> rtpmanager.v1.SessionStatus
	2,  // 12: rtpmanager.v1.RTPManagerService.CreateSession:input_type -> rtpmanager.v1.CreateSessionRequest
	4,  // 13: rtpmanager.v1.RTPManagerService.DestroySession:input_type -> rtpmanager.v1.DestroySessionRequest
	6,  // 14: rtpmanager.v1.RTPManagerService.PlayAudio:input_type -> rtpmanager.v1.PlayAudioRequest
	13, // 15: rtpmanager.v1.RTPManagerService.StopAudio:input_type -> rtpmanager.v1.StopAudioRequest
	15, // 16: rtpmanager.v1.RTPManagerService.Health:input_type -> rtpmanager.v1.HealthRequest
	18, // 17: rtpmanager.v1.RTPManagerService.UpdateSessionRemote:input_type -> rtpmanager.v1.UpdateSessionRemoteRequest
	20, // 18: rtpmanager.v1.RTPManagerService.BridgeMedia:input_type -> rtpmanager.v1.BridgeMediaRequest
	22, // 19: rtpmanager.v1.RTPManagerService.UnbridgeMedia:input_type -> rtpmanager.v1.UnbridgeMediaRequest
	3,  // 20: rtpmanager.v1.RTPManagerService.CreateSession:output_type -> rtpmanager.v1.CreateSessionResponse
	5,  // 21: rtpmanager.v1.RTPManagerService.DestroySession:output_type -> rtpmanager.v1.DestroySessionResponse
	7,  // 22: rtpmanager.v1.RTPManagerService.PlayAudio:output_type -> rtpmanager.v1.PlaybackEvent
	14, // 23: rtpmanager.v1.RTPManagerService.StopAudio:output_type -> rtpmanager.v1.StopAudioResponse
	16, // 24: rtpmanager.v1.RTPManagerService.Health:output_type -> rtpmanager.v1.HealthResponse
	19, // 25: rtpmanager.v1.RTPManagerService.UpdateSessionRemote:output_type -> rtpmanager.v1.UpdateSessionRemoteResponse
	21, // 26: rtpmanager.v1.RTPManagerService.BridgeMedia:output_type -> rtpmanager.v1.BridgeMediaResponse
	23, // 27: rtpmanager.v1.RTPManagerService.UnbridgeMedia:output_type -> rtpmanager.v1.UnbridgeMediaResponse
	20, // [20:28] is the sub-list for method output_type
	12, // [12:20] is the sub-list for method input_type
	12, // [12:12] is the sub-list for extension type_name
	12, // [12:12] is the sub-list for extension extendee
	0,  // [0:12] is the sub-list for field type_name
}

func init() { file_api_proto_rtpmanager_v1_rtpmanager_proto_init() }
func file_api_proto_rtpmanager_v1_rtpmanager_proto_init() {
	if File_api_proto_rtpmanager_v1_rtpmanager_proto != nil {
		return
	}
	file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes[5].OneofWrappers = []any{
		(*PlaybackEvent_Started)(nil),
		(*PlaybackEvent_Progress)(nil),
		(*PlaybackEvent_Completed)(nil),
		(*PlaybackEvent_Error)(nil),
		(*PlaybackEvent_Stopped)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_api_proto_rtpmanager_v1_rtpmanager_proto_rawDesc), len(file_api_proto_rtpmanager_v1_rtpmanager_proto_rawDesc)),
			NumEnums:      2,
			NumMessages:   22,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_api_proto_rtpmanager_v1_rtpmanager_proto_goTypes,
		DependencyIndexes: file_api_proto_rtpmanager_v1_rtpmanager_proto_depIdxs,
		EnumInfos:         file_api_proto_rtpmanager_v1_rtpmanager_proto_enumTypes,
		MessageInfos:      file_api_proto_rtpmanager_v1_rtpmanager_proto_msgTypes,
	}.Build()
	File_api_proto_rtpmanager_v1_rtpmanager_proto = out.File
	file_api_proto_rtpmanager_v1_rtpmanager_proto_goTypes = nil
	file_api_proto_rtpmanager_v1_rtpmanager_proto_depIdxs = nil
}
